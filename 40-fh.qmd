---
bibliography: references.bib
---

# The Univariate Fay-Herriot model

## Introduction

In this section, we will present a whole estimation procedure of the standard area-level model introduced by @Fay1979 in R. As with the disclaimer in the preceding section, this practical manual is not intended to serve as a theoretical introduction to area-level models. Instead, it offers a set of straightforward and practical R scripts, accompanied by clear explanations, to demonstrate how these tasks can be carried out in R. For a theoretical foundation please refer to @Fay1979 and @RaoMolina2015. In addition to theoretical information, the vignette "A framework for producing small area estimates based on area-level models in R" of the R package `emdi` [@Harmening2023] provides further code examples for the FH model.

In this chapter, we will describe how to run the univariate Fay-Herriot (FH) using simulated income data from Spain. The estimation procedure is explained step by step.

Step 1: Data preparation. Compute the direct estimates and their corresponding variances on the area-level and eventually perform variance smoothing. Aggregate the available auxiliary variables to the same area level and combine both input data.

Step 2: Model selection. Select the aggregated auxiliary variables at the area level for the FH model using a stepwise selection based on information criteria like the Akaike, Bayesian or Kullback information criteria.

Step 3: Model estimation of FH point estimates and their mean squared error (MSE) estimates as uncertainty measure. Eventually apply a transformation.

Step 4: Assessment of the estimated model. Check the FH model assumptions, including linearity, normality of predicted area effects and standardized model residuals. When violations of the model assumptions are detected, the application of a transformation might help. Repeat Step 3 including a transformation and check again the model assumptions.

Step 5: Comparison of the FH results with the direct estimates.

Step 6: Benchmark the FH point estimates for consistency with higher results.

Step 7: Preparation of the results. Create tables and maps of results.

Step 8: Saving the results. One option is to export the results to known formats like Excel or OpenDocument Spreadsheets.

We will show below the use of the `fh()` function of the R package `emdi` [@Harmening2023] which computes the EBLUPs and their MSE estimates of the standard FH model and several extensions of it, among others it allows for the application of transformations. Because the poverty rate is a ratio, it might be helpful to apply the arcsin transformation to guarantee that the results lie between 0 and 1. The function call is:

`fh(fixed, vardir, combined_data, domains = NULL, method = "reml", interval = NULL,   k = 1.345, mult_constant = 1, transformation = "no", backtransformation = NULL,   eff_smpsize = NULL, correlation = "no", corMatrix = NULL, Ci = NULL, tol = 1e-04,   maxit = 100, MSE = FALSE, mse_type = "analytical", B = c(50, 0), seed = 123)`

## Data and preparation

### Load required libraries

First of all, load the required R libraries. The code automatically installs the packages that are not yet installed and loads them. If you need further packages, please add them to the list of `p_load` which contains the packages required to the run the codes.

```{r libraries, message = FALSE, warning = FALSE}
if (sum(installed.packages()[,1] %in% "pacman") != 1){
  
  install.packages("pacman")
  
}

pacman::p_load(sae, survey, spdep, emdi, data.table, MASS, caret, dplyr, sf)

```

### Load the dataset

Usually, SAE combines multiple data sources: a survey data set and a census or administrative/register dataset. For the estimation of area-level models, we need area-level aggregates of the same area-level (e.g. NUTS3) of both datasets. The target variable (typically household welfare/income for poverty mapping) is available in the survey but not in the census data.

In this example, we use a synthetic data set adapted from R package `sae` called `incomedata`. The original data contains information for $n = 17,119$ fictitious individuals residing across $D = 52$ Spanish provinces. The variables include the name of the province of residence (`provlab`), province code (`prov`), as well as several correlates of income.

For this exercise, we use a random 10% sample of the `incomedata` to estimate the poverty rates. For the univariate case, we use the income variable from 2012.

```{r load_data, message = FALSE, warning = FALSE}
sample_dt <- readRDS("data/incomedata_sample.RDS")
glimpse(sample_dt)

aux_dt <- readRDS("data/incomedata_sample.RDS")
glimpse(aux_dt)
```

### Direct estimation

We will use the direct Horvitz-Thompons estimators that use the survey weights in `weight` variable. We calculate the sample sizes for each provinces and compute the direct estimates and their variances. We use the `direct` function of the `emdi` package here. Other options are e.g. the `direct` function of package `sae` [@molinamarhuenda2015] or the `svyby` command of package `survey` [@Lumley2024]. Then, we create a dataframe containing the direct estimate, the standard errors, the variances, the coefficient of variation and the design effects, that are needed for the arcsin transformation. The design effect is the ratio of the variance considering the sampling design to the variance estimated under simple random sampling. For detailled information about the arcsin transformation please refer to @Casas2016 and @Schmid2017. In some areas with a very small sample size, it may occur, that the individual data only consists of zeros and ones, resulting in a direct estimate of zero or one and a direct variance of zero. We set those areas to out-of-sample and for the final estimation results only the synthetic part of the FH model is used.

```{r direct, message = FALSE, warning = FALSE}
## calculate sample size for each province
sampsize_dt <- 
income_dt |>
  group_by(provlab) |>
  summarize(N = n())

## computation of direct estimates and their variances
direct_dt <- emdi::direct(y = "income2012",
                       smp_data = income_dt |> as.data.table(),
                       smp_domains = "provlab",
                       weights = "weight",
                       threshold = unique(income_dt$povline2012),
                       var = TRUE)

## create dataframe
direct_dt <- 
       direct_dt$ind |>
       dplyr::select(Domain, Head_Count) |>
       rename(Direct = "Head_Count") |>
       merge(direct_dt$MSE |>
               dplyr::select(Domain, Head_Count) |>
               rename(vardir = "Head_Count"),
             by = "Domain") |>
       mutate(SD = sqrt(vardir)) |>
       mutate(CV = SD / Direct) |>
       merge(sampsize_dt |> 
               mutate(provlab = as.factor(provlab)), 
             by.x = "Domain", 
             by.y = "provlab") |>
      mutate(var_SRS = Direct * (1 - Direct) / N) |>
      mutate(deff = vardir / var_SRS) |>
      mutate(n_eff = N/deff)

## set zero variance to OOS
direct_dt <- direct_dt[complete.cases(direct_dt), ]

## have a look at sample sizes
summary(direct_dt$N)    
```

### Variance smoothing

A quick inspection of the preceding results will show some provinces contain low sample sizes which sometimes result in extreme value poverty rates and hence 0 variance. To avoid this, we will show you how to apply the variance smoothing method suggested by @you2023application. Please see the code and Roxygen comments below explaining the use of the `varsmoothie_king()` function which computes smoothed variances. In case, the arcsin transformation will be applied, the variance smoothing described here is not necessary, since the arcsin transformation works variance stabilizing itself. When applying the arcsin transformation, the direct variances are automatically set to 1/(4\*effective sampling size) when using the `fh` function of package `emdi`. The effective sample size equals the sample size of each area divided by the design effect. If the variance stabilizing effect is not enough, the design effect of a higher area level could also be used here (in this example the regions `ac`).

The goal now is to use the `varsmoothie_king()` function to add an additional column of smoothed variances into our `direct_dt` dataframe. Required inputs: a vector of unique domains, the raw variances estimated from sample data and the sample size for each domain.

```{r}
source("R/var_smoothing.R")

var_smooth <- varsmoothie_king(domain = direct_dt$Domain,
                               direct_var = direct_dt$vardir,
                               sampsize = direct_dt$N)

direct_dt <- var_smooth |> merge(direct_dt, by = "Domain")

# Replace the variances that are zero with their smoothed counterparts
direct_dt <- 
  direct_dt |>
  mutate(across(
    starts_with("v_"),
    ~ if_else(abs(.x) <= 1e-4, get(paste0("vsv", str_remove(cur_column(), "^v"))), .x),
    .names = "{.col}"
  ))
```

### Auxiliary variable preparation

The FH model is a model of poverty rates at the target area level, hence the data format required for this exercise has the province as its unit of observation. This format has a few essential columns:

-   Variable for poverty rates

-   The set of candidate variables from which the most predicted of poverty rates will be selected

-   The target area variable identifier (i.e. in this case the province variable `prov` and `provlab`)

We prepare this dataset as follows:

```{r}
## create the candidate variables
candidate_vars <- colnames(income_dt)[!colnames(income_dt) %in% 
                                         c("provlab", "prov", 
                                           "income2012", "income2013", "income2014",
                                           "povline2012", "povline2013", "povline2014",
                                           "ac", "nat", "educ", "labor",
                                           "age")]
 
## change dummy of gen to 0 and 1
income_dt <- 
  income_dt |>
  mutate(across(c(gen), ~ case_when(
    .x == 1 ~ 0,
    .x == 2 ~ 1,
    TRUE ~ NA_real_
  )))

## aggregating the unit-level data to the province level
prov_dt <- 
income_dt |>
  group_by(provlab) |>
  summarize(
    across(
      any_of(candidate_vars),
      ~ weighted.mean(x = ., w = weight, na.rm = TRUE),
      .names = "{.col}"
    )
  )

### combine the the dataframe containing the direct estimates and their variances with the province level data
comb_Data <- merge(direct_dt, prov_dt,
    by.x = "Domain", by.y = "provlab",
    all = TRUE)

```

## Model selection

### Model preparation

FH does not run if there is any missing value in the auxiliary variables, and therefore, any variable with missing value should be removed in advance.

```{r fh_model, message = FALSE, warning = FALSE}
rowsNAcovariates <- rowSums(sapply(comb_Data[,..candidate_vars], is.na))
comb_Data <- comb_Data[rowsNAcovariates == 0, ]
```

### Check multicollinearity

With the help of the `step()` function of package `emdi`, we perform a variable selection based on the chosen variable selection criterion and directly get the model with fewer variables. The function `step_wrapper()` implemented below is a wrapper to the `emdi::step()` function and performs all the perfunctory cleaning necessary to use `step()`. This includes dropping columns that are entirely missing (`NA`) and keep only complete cases/observations (for the model selection only the in-sample domains are used) and remove perfectly or near collinear variables and combinations.

We apply the function to select the variables. Required inputs: data set, character vector containing the set of auxiliary variables, name of y variable, a correlation threshold between 0 and 1, name of information criterion and name of direct variance variable. In case, a transformation should be applied, "arcsin" as transformation and name of variable that contains the effective sample size.

```{r remove_multicol, message = FALSE, warning = FALSE}
source("R/model_select.R")

fh_step <- step_wrapper(dt = comb_Data, 
                        xvars = candidate_vars,
                        y = "Direct",
                        cor_thresh = 0.8,
                        criteria = "AIC",
                        vardir = "vardir", 
                        transformation = "arcsin", 
                        eff_smpsize = "n_eff")

print(fh_step$fixed)
```

## Model estimation of FH point and their MSE estimates.

In this example, we use the function `fh` to calculate the FH estimates. Because we want to estimate a ratio, we need to apply the arcsin transformation to guarantee that the results lie between 0 and 1. For that, we choose "arcsin" as `transformation`, and a bias-corrected `backtransformation` ("bc"). Additionally, the effective sample size, which equals the sample size of each area divided by the design effect, is needed for the arcsin transformation. We set the `MSE` estimation to `TRUE`, the `mse_type` to "boot" (necessary for the type of transformation) and determine the number of bootstrap iterations. For practical applications, values larger than 200 are recommended. In case, no transformation is desired, the `transformation` argument must be set to "no" and the inputs `backtransformation` and `eff_smpsize` are no longer needed.

```{r model_est, message = FALSE, warning = FALSE}
fh_model <- fh(fixed = formula(fh_step$fixed),
               vardir = "vardir", 
               combined_data = comb_Data, 
               domains = "Domain",
               method = "ml", 
               transformation = "arcsin", 
               backtransformation = "bc",
               eff_smpsize = "n_eff", 
               MSE = TRUE, 
               mse_type = "boot", B = c(50, 0)) 

## In case, no transformation is desired, the call would like this:
# fh_model <- fh(
#   fixed = Direct ~ age2 + age3 + age4 + age5 + educ1 + ntl + schyrs, #formula(fh_step$fixed),
#   vardir = "vardir", combined_data = comb_Data, domains = "Domain",
#   method = "ml", MSE = TRUE) 
```

## Assessment of the estimated model.

With the help of the `summary` method of `emdi`, we gain detailed insights into the data and model components. It includes information on the estimation methods used, the number of domains, the log-likelihood, and information criteria as proposed by @Marhuenda2014. It also reports the adjusted $R^2$ from a standard linear model and the adjusted $R^2$ specific to FH models, as introduced by @Lahiri2015. It also offers diagnostic measures to assess model assumptions regarding the standardized realized residuals and random effects. These include skewness and kurtosis (based on the `moments` package by @Komsta2015), as well as Shapiro-Wilk test statistics and corresponding p-values to evaluate the normality of both error components.

```{r summary, message = FALSE, warning = FALSE}
summary(fh_model)
```

We can see, that 49 domains are in-sample domains. The 3 out-of-sample domains belong to the domains with 0 direct and variance estimates that we set to `NA` in the beginning. The variance of the random effects equals 7.643268e-05. All of the included auxiliary variables are significant on a 0.05 significance level and their explanatory power is large with an adjusted $R^2$ (for FH models) of around 0.74. The results of the Shapiro-Wilk-test indicate that normality is not rejected for both errors.

### Diagnostic plots

We produce normal quantile-quantile (Q-Q) plots of the standardized realized residuals and random effects and plots of the kernel densities of the distribution of both error terms by the `plot` method of `emdi`.

```{r plot, message = FALSE, warning = FALSE}
plot(fh_model)
```

The plots show slight deviations of the distributions from normality, but together with the results of the Shapiro-Wilk-test, we do not reject the normality assumption.

## Comparison of the FH results with the direct estimates.

The FH estimates are expected to align closely with the direct estimates in domains with small direct MSEs and/or large sample sizes. Moreover, incorporating auxiliary information should enhance the precision of the direct estimates. We produce a scatter plot proposed by @Brown2001 and a line plot. The fitted regression and the identity line of the scatter plot should not differ too much. The FH estimates should track the direct estimates within the line plot especially for domains with a large sample size/small MSE of the direct estimator. Furthermore, we compare the MSE and CV estimates for the direct and FH estimators using boxplots and ordered scatter plots (by setting the input arguments `MSE` and `CV` to `TRUE`).

Additionally, we compute a correlation coefficient of the direct estimates and the estimates of the regression-synthetic part of the FH model [@Chandra2015] and a goodness of fit diagnostic [@Brown2001].

```{r compare, message = FALSE, warning = FALSE}
compare_plot(fh_model, MSE = TRUE, CV = TRUE)
compare(fh_model)

```

The direct estimates are tracked by most of the FH estimates within the line plot. The precision of the direct estimates could be improved by the usage of the FH model in terms of MSEs and CVs. The null hypothesis of the Brown test is not rejected and the correlation coefficient indicates a positive correlation (0.68) between the direct and FH estimates.

If the result of the model assessment is not satisfactory, the following should be checked again: Can the direct estimation including variance estimation be improved? Are there further auxiliary variables and/or must possible interaction effects be taken into account? Does a (different) transformation need to be used?

## Benchmark the FH point estimates for consistency with higher results.

Benchmarking is based on the principle that aggregated FH estimates should sum up to the estimates at a higher regional level. For the benchmark function, a benchmark value and a vector containing the shares of the population size per area ($N_d/N$) is required. Please note, that only the FH estimates are benchmarked and not their MSE estimates. As benchmark types "raking", "ratio" and "MSE_adj" can be chosen. For further details about using the function, please refer to the `emdi` vignette and for general information about the benchmarking options to @Datta2011.

```{r benchmarking, message = FALSE, warning = FALSE}
## create the poverty indicator
income_dt <- 
  income_dt |>
  mutate(poor2012 = ifelse(income2012 < povline2012, 1, 0))

## compute the benchmark value (mean of poor2012 for the whole country of Spain)
benchmark_value <- weighted.mean(income_dt$poor2012, income_dt$weight)

## compute the share of population size in the total population size (N_d/N) per area
data("sizeprov")
comb_Data <- comb_Data |>
  left_join(sizeprov |>
  mutate(ratio_n = Nd/sum(Nd)), by = c("Domain" ="provlab"))

fh_bench <- benchmark(fh_model,
                      benchmark = benchmark_value,
                      share = comb_Data$ratio_n, 
                      type = "ratio",
                      overwrite = TRUE)
head(fh_bench$ind)
```

## Preparation of the results.

Create one dataframe that contains the direct and FH estimation results including MSE and CV results.

```{r res_prep, message = FALSE, warning = FALSE}
results <-as.data.frame(estimators(fh_model, MSE = TRUE, CV = TRUE))
head(results)
```

### Poverty map

With the help of geographical maps, the results can be presented in a user-friendly way and differences among the areas can be detected more easily. For the map, a shape file is reqired. The domain identifiers in the results object (`fh_model`) need to match to the respective identifiers of the shape file. Therefore, we create a mapping table first and then produce the map by `emdi::map_plot`.

```{r fig-povmap}
## load the shapefile dataframe and convert it to an object of type sf which is a necessary input for the map_plot function
spain_dt <- readRDS("data/shapes/spainshape.RDS")
spain_dt <- sf::st_as_sf(spain_dt)

## Create a suitable mapping table
## Find the right order
domain_ord <- match(spain_dt$provlab, fh_model$ind$Domain)

## Create the mapping table based on the order obtained above
map_tab <- data.frame(pop_data_id = fh_model$ind$Domain[domain_ord],
                      shape_id = spain_dt$provlab)

## Create map
map_plot(object = fh_model, MSE = TRUE, map_obj = spain_dt,
 map_dom_id = "provlab", map_tab = map_tab)

```

## Saving the results.

### Save workspace.

```{r save, message = FALSE, warning = FALSE, eval = FALSE}
save.image("fh_estimation.RData")
```

### Export the model output and estimation results.

```{r saveexcel, message = FALSE, warning = FALSE, eval = FALSE}
write.excel(fh_model,
  file = "fh_model_output.xlsx",
  MSE = TRUE, CV = TRUE
)
```