---
title: "The Univariate Fay-Herriot model"
author: "Sylvia Harmening"
format: html
editor: visual
bibliography: references.bib
---

```{r, echo = FALSE, include = FALSE, warning = FALSE, message=FALSE, error =  FALSE}
#| label: setup
#| echo: false
#| warning: false
#| message: false
#| error: false

# Chunk setup
knitr::opts_chunk$set(
  echo = FALSE,
  message = FALSE,
  warning = FALSE,
  error = FALSE
)

pak_list <- c("sf", "data.table", "tidyverse", "car", 
              "sae", "survey", "spdep", "knitr", "MASS", "caret",
              "caret", "purrr", "pins", "gt",  "scales",
              "viridis", "emdi", "rlang")

sapply(pak_list,
       library,
       character.only = TRUE)


# Loading locally-developed
list.files("R", pattern="*.R$", full.names=TRUE, ignore.case=TRUE) |> 
  walk(source)

# Raw data root
root_raw <- "./data/raw"
root_temp <- "./data/temp"
root_clean <- "./data/clean-example"

# Data-storage boards
bd_raw <- root_raw |> file.path("api") |> board_folder(versioned = T)
bd_aux <- root_temp |> board_folder(versioned = T)
bd_clean <- root_clean |> board_folder(versioned = T)
bd_out <- board_folder("data/clean-example", versioned = TRUE)

```

## Introduction

In this section, we will present a whole estimation procedure of the standard area-level model introduced by @Fay1979 in R. As with the disclaimer in the preceding section, this practical manual is not intended to serve as a theoretical introduction to area-level models. Instead, it offers a set of straightforward and practical R scripts, accompanied by clear explanations, to demonstrate how these tasks can be carried out in R. For a theoretical foundation please refer to @Fay1979 and @RaoMolina2015. In addition to theoretical information, the vignette "A framework for producing small area estimates based on area-level models in R" of the R package `emdi` [@Harmening2023] provides further code examples for the FH model.

In this chapter, we will describe how to run the univariate Fay-Herriot (FH) using simulated income data from Spain. The estimation procedure is explained step by step.

Step 1: Data preparation. Compute the direct estimates and their corresponding variances on the area-level and eventually perform variance smoothing. Aggregate the available auxiliary variables to the same area level and combine both input data.

Step 2: Model selection. Select the aggregated auxiliary variables at the area level for the FH model using a stepwise selection based on information criteria like the Akaike, Bayesian or Kullback information criteria.

Step 3: Model estimation of FH point estimates and their mean squared error (MSE) estimates as uncertainty measure. Eventually apply a transformation.

Step 4: Assessment of the estimated model. Check the FH model assumptions, including linearity, normality of predicted area effects and standardized model residuals. When violations of the model assumptions are detected, the application of a transformation might help. Repeat Step 3 including a transformation and check again the model assumptions.

Step 5: Comparison of the FH results with the direct estimates.

Step 6: Benchmark the FH point estimates for consistency with higher results.

Step 7: Preparation of the results. Create tables and maps of results.

Step 8: Saving the results. One option is to export the results to known formats like Excel or OpenDocument Spreadsheets.

We will show below the use of the `fh()` function of the R package `emdi` [@Harmening2023] which computes the EBLUPs and their MSE estimates of the standard FH model and several extensions of it, among others it allows for the application of transformations. Because the poverty rate is a ratio, it might be helpful to apply the arcsin transformation to guarantee that the results lie between 0 and 1. The function call is:

`fh(fixed, vardir, combined_data, domains = NULL, method = "reml", interval = NULL,   k = 1.345, mult_constant = 1, transformation = "no", backtransformation = NULL,   eff_smpsize = NULL, correlation = "no", corMatrix = NULL, Ci = NULL, tol = 1e-04,   maxit = 100, MSE = FALSE, mse_type = "analytical", B = c(50, 0), seed = 123)`

## Data and preparation

### Load the dataset

Usually, SAE combines multiple data sources: a survey data set and a census or administrative/register dataset. For the estimation of area-level models, we need area-level aggregates of the same area-level (e.g. NUTS3) of both datasets. The target variable (typically household welfare/income for poverty mapping) is available in the survey but not in the census data.

In this example, we use a synthetic data set adapted from R package `sae` called `incomedata`. The original data contains information for $n = 17,119$ fictitious individuals residing across $D = 52$ Spanish provinces. The variables include the name of the province of residence (`provlab`), province code (`prov`), as well as several correlates of income.

For this exercise, we use a random 10% sample of the `incomedata` to estimate the poverty rates. For the univariate case, we use the income variable from 2012.

The FH estimation process relies on 3 types of data: 

(1) The data containing the outcome variable from which direct estimates will be computed. This is a usually a survey dataset for each year of data including outcome variable (such as income or welfare aggregates), weights, cluster identifiers (i.e. if available, psu or enumeration areas) at the unit level i.e. individual or household. In this example, we call this: `survey_dt`.

(2) A dataset containing for the right hand side (RHS) variables i.e. indicator estimates representative at the level of the target area. This is often obtained from administrative data sources or geospatial data such as remotely sensed high resolution data. The final RHS dataset ought to include an area id and variables of interest. In this example, we call this `rhs_dt`.

(3) Finally, a shapefile which spatially links each target area to their boundaries on a map. This will contain the area id as well as the geometry object which when visualized will show the shape of the areas in which poverty rates will be estimated. In this example, we call this `shp_dt`. 

```{r load-data, message = FALSE, warning = FALSE}

### lets read in our 3 aforementioned datasets 

survey_dt <- 
  bd_clean |>
  pin_read("pov_direct")


rhs_dt <- 
  bd_clean |>
  pin_read("sae_data")
  

shp_dt <- 
  bd_clean |>
  pin_read("geometries")


```

Below is what our datasets look like. These are generally the variables  

```{r}

survey_dt |>
  glimpse()

```
`survey_dt` contains our target area identifiers (`provlab`, `prov`), the weight variable `weight`, the cluster id i.e. enumeration area or psu, `ea_id`, the year, `year`, the income variable `income` and the poverty line `poverty`. In this example, `survey_dt` of class `data.frame` is at the level of the individual. It could also be at the level of the household if poverty lines are evaluated at that level. 

```{r}

rhs_dt |>
  glimpse()

```
``rhs_dt` is an object of class `data.frame` created at the level of the target area. It should contain the same target area identifiers as in `survey_dt` and the year variable `year`. 


```{r}

shp_dt |>
  glimpse()

```
`shp_dt` is an object of class `sf`, `data.frame` created at the level of the target area. This is the shapefile for the area of interest for which the poverty map will be estimated. It should contain the same target area ID found in `survey_dt` as well as `rhs_dt`. 

A quick summary table on the data needs for the MFH model: 
```{r}

# Create the table content
fh_table <- tibble::tibble(
  Dataset = c("`survey_dt`", "`rhs_dt`", "`shp_dt`"),
  `Unit of Observation` = c(
    "Individual (or Household)",
    "Target Area (e.g. Province)",
    "Target Area (Spatial)"
  ),
  `Required Variables` = c(
    "`target area identifiers`, `weights`, `cluster identifier`, year, `income/welfare variable`, `poverty line`",
    "`target area identifiers`, `year`, `covariates` (e.g. `gen`, `educ1`, `schyrs`, etc.)",
    "`target area identifiers`, `geometries` (e.g. `geometry` column from `sf`)"
  )
)


# Build the gt table
fh_table %>%
 gt() %>%
  tab_header(
    title = md("**Data Input Checklist for the Univariate Fay-Herriot Model**"),
    subtitle = md("*Datasets, levels, and Required variables*")
  ) %>%
  cols_label(
    Dataset = "Dataset Name",
    `Unit of Observation` = "Unit of Observation",
    `Required Variables` = "Required Variables"
  ) %>%
  tab_options(
    table.font.names = "Arial",
    heading.title.font.size = 16,
    heading.subtitle.font.size = 12,
    table.font.size = 12,
    column_labels.font.weight = "bold",
    data_row.padding = px(4),
    table.border.top.width = px(2),
    table.border.bottom.width = px(2),
    heading.align = "left"
  ) %>%
  fmt_markdown(columns = everything())

```


### Direct estimation

We will use the direct Horvitz-Thompons estimators that use the survey weights in `weight` variable. We calculate the sample sizes for each provinces and compute the direct estimates and their variances. We use the `direct` function of the `emdi` package here. Other options are e.g. the `direct` function of package `sae` [@molinamarhuenda2015] or the `svyby` command of package `survey` [@Lumley2024]. Then, we create a dataframe containing the direct estimate, the standard errors, the variances, the coefficient of variation and the design effects, that are needed for the arcsin transformation. The design effect is the ratio of the variance considering the sampling design to the variance estimated under simple random sampling. For detailled information about the arcsin transformation please refer to @Casas2016 and @Schmid2017. In some areas with a very small sample size, it may occur, that the individual data only consists of zeros and ones, resulting in a direct estimate of zero or one and a direct variance of zero. We set those areas to out-of-sample and for the final estimation results only the synthetic part of the FH model is used.

```{r direct, message = FALSE, warning = FALSE}
### a little bit of housekeeping to ensure ease of access 
area_vars <- c("prov", "provlab") ### both variables are at the same level. If the levels vary, you would need to combine both variables for effect use

cluster_var <- "ea_id"

weight_var <- "weight"

year_var <- "year"

outcome_var <- "income"

povline_var <- "povline"

candidate_vars <- colnames(rhs_dt)[!colnames(rhs_dt) %in% c(area_vars, year_var)]

## For the univariate model, we only use a single year (here 2012)
singleyear <- "2012"

survey_dt <- survey_dt |>
  filter(year == singleyear)

rhs_dt <- rhs_dt |>
  filter(year == singleyear)


## calculate sample size for each province
sampsize_dt <- 
survey_dt |>
  group_by(!!!syms(area_vars[1])) |>
  summarize(N = n())

## computation of direct estimates and their variances (the poverty line is already included within the data)
## creating the poverty indicator
survey_dt <- 
  survey_dt |>
  mutate(pov_indicator = ifelse(income < povline, 1, 0))


### creating a survey object
design_obj <- survey::svydesign(ids = eval(expr(~!!sym(cluster_var))), 
                                weights = eval(expr(~!!sym(weight_var))), 
                                data = survey_dt)

var_dt <- survey::svyby(~pov_indicator, by=eval(expr(~!!sym(area_vars[1]))), design = design_obj, FUN = survey::svymean)


direct_dt <- 
  var_dt |>
  rename(direct_povrate = "pov_indicator") |>
  rename(SD = "se") |>
  mutate(vardir = SD^2) |>
  mutate(CV = SD / direct_povrate) |>
  merge(sampsize_dt, 
        by = area_vars[[1]]) |>
  mutate(var_SRS = direct_povrate * (1 - direct_povrate) / N) |>
  mutate(deff = vardir / var_SRS) |>
  mutate(n_eff = N/deff)

## set zero variance to OOS
direct_dt <- direct_dt[complete.cases(direct_dt), ]

```


Here is what the results look like: 

```{r}

direct_dt

```

### Variance smoothing

A quick inspection of the preceding results will show some provinces contain low sample sizes which sometimes result in extreme value poverty rates and hence 0 variance. To avoid this, we will show you how to apply the variance smoothing method suggested by @you2023application. Please see the code and Roxygen comments below explaining the use of the `varsmoothie_king()` function which computes smoothed variances. In case, the arcsin transformation will be applied, the variance smoothing described here is not necessary, since the arcsin transformation works variance stabilizing itself. When applying the arcsin transformation, the direct variances are automatically set to 1/(4\*effective sampling size) when using the `fh` function of package `emdi`. The effective sample size equals the sample size of each area divided by the design effect. If the variance stabilizing effect is not enough, the design effect of a higher area level could also be used here (in this example the regions `ac`).

The goal now is to use the `varsmoothie_king()` function to add an additional column of smoothed variances into our `direct_dt` dataframe. Required inputs: a vector of unique domains, the raw variances estimated from sample data and the sample size for each domain.

```{r}
var_smooth <- varsmoothie_king(domain = direct_dt[[area_vars[1]]],
                               direct_var = direct_dt$vardir,
                               sampsize = direct_dt$N)

direct_dt <- var_smooth |> merge(direct_dt, by.x = "Domain",
        by.y = area_vars[1])

# Replace the variances that are zero with their smoothed counterparts
direct_dt <- 
  direct_dt |>
  mutate(across(
    starts_with("v_"),
    ~ if_else(abs(.x) <= 1e-4, get(paste0("vsv", str_remove(cur_column(), "^v"))), .x),
    .names = "{.col}"
  ))
```


Thus far, we have careful set up the types of data we require for the FH model. We only need to combine the dataframe containing the direct estimates and their variances with the auxiliary variables.

```{r}
fh_dt <- merge(direct_dt, rhs_dt,
    by.x = "Domain", by.y = area_vars[[1]],
    all = TRUE)

```

## Model selection

### Model preparation

FH does not run if there is any missing value in the auxiliary variables, and therefore, any variable with missing value should be removed in advance.

```{r fh_model, message = FALSE, warning = FALSE}
rowsNAcovariates <- rowSums(sapply(fh_dt[,..candidate_vars], is.na))
fh_dt <- fh_dt[rowsNAcovariates == 0, ]
```

### Check multicollinearity

With the help of the `step()` function of package `emdi`, we perform a variable selection based on the chosen variable selection criterion and directly get the model with fewer variables. The function `step_wrapper()` implemented below is a wrapper to the `emdi::step()` function and performs all the perfunctory cleaning necessary to use `step()`. This includes dropping columns that are entirely missing (`NA`) and keep only complete cases/observations (for the model selection only the in-sample domains are used) and remove perfectly or near collinear variables and combinations.

We apply the function to select the variables. Required inputs: data set, character vector containing the set of auxiliary variables, name of y variable, a correlation threshold between 0 and 1, name of information criterion and name of direct variance variable. In case, a transformation should be applied, "arcsin" as transformation and name of variable that contains the effective sample size.

```{r remove_multicol, message = FALSE, warning = FALSE}
fh_step <- step_wrapper_fh(dt = fh_dt,
                           xvars = candidate_vars,
                           y = "direct_povrate",
                           cor_thresh = 0.8,
                           criteria = "BIC",
                           vardir = "vardir", 
                           transformation = "arcsin", 
                           eff_smpsize = "n_eff")

print(fh_step$fixed)
```

## Model estimation of FH point and their MSE estimates.

In this example, we use the function `fh` to calculate the FH estimates. Because we want to estimate a ratio, we need to apply the arcsin transformation to guarantee that the results lie between 0 and 1. For that, we choose "arcsin" as `transformation`, and a bias-corrected `backtransformation` ("bc"). Additionally, the effective sample size, which equals the sample size of each area divided by the design effect, is needed for the arcsin transformation. We set the `MSE` estimation to `TRUE`, the `mse_type` to "boot" (necessary for the type of transformation) and determine the number of bootstrap iterations. For practical applications, values larger than 200 are recommended. In case, no transformation is desired, the `transformation` argument must be set to "no" and the inputs `backtransformation` and `eff_smpsize` are no longer needed.

```{r model_est, message = FALSE, warning = FALSE}
set.seed(123)
fh_model <- fh(fixed = formula(fh_step$fixed),
               vardir = "vardir", 
               combined_data = fh_dt, 
               domains = "Domain",
               method = "ml", 
               transformation = "arcsin", 
               backtransformation = "bc",
               eff_smpsize = "n_eff", 
               MSE = TRUE, 
               mse_type = "boot", B = c(200, 0)) 

## In case, no transformation is desired, the call would like this:
# fh_model <- fh(
#   fixed = Direct ~ age2 + age3 + age4 + age5 + educ1 + ntl + schyrs, #formula(fh_step$fixed),
#   vardir = "vardir", combined_data = comb_Data, domains = "Domain",
#   method = "ml", MSE = TRUE) 
```

## Assessment of the estimated model.

With the help of the `summary` method of `emdi`, we gain detailed insights into the data and model components. It includes information on the estimation methods used, the number of domains, the log-likelihood, and information criteria as proposed by @Marhuenda2014. It also reports the adjusted $R^2$ from a standard linear model and the adjusted $R^2$ specific to FH models, as introduced by @Lahiri2015. It also offers diagnostic measures to assess model assumptions regarding the standardized realized residuals and random effects. These include skewness and kurtosis (based on the `moments` package by @Komsta2015), as well as Shapiro-Wilk test statistics and corresponding p-values to evaluate the normality of both error components.

```{r summary, message = FALSE, warning = FALSE}
summary(fh_model)
```

We can see, that 49 domains are in-sample domains. The 3 out-of-sample domains belong to the domains with 0 direct and variance estimates that we set to `NA` in the beginning. The variance of the random effects equals 0.001516632. All of the included auxiliary variables are significant on a 0.05 significance level and their explanatory power is large with an adjusted $R^2$ (for FH models) of around 0.74. The results of the Shapiro-Wilk-test indicate that normality is not rejected for the standardized residuals.

### Diagnostic plots

We produce normal quantile-quantile (Q-Q) plots of the standardized realized residuals and random effects and plots of the kernel densities of the distribution of both error terms by the `plot` method of `emdi`.

```{r plot, message = FALSE, warning = FALSE}
plot(fh_model)
```

The plots show slight deviations of the distributions from normality. The normality assumption is not required for the computation of the FH estimates, but at the obtained MSE estimates we have to look with some care when the normality assumption does not hold.

## Comparison of the FH results with the direct estimates.

The FH estimates are expected to align closely with the direct estimates in domains with small direct MSEs and/or large sample sizes. Moreover, incorporating auxiliary information should enhance the precision of the direct estimates. We produce a scatter plot proposed by @Brown2001 and a line plot. The fitted regression and the identity line of the scatter plot should not differ too much. The FH estimates should track the direct estimates within the line plot especially for domains with a large sample size/small MSE of the direct estimator. Furthermore, we compare the MSE and CV estimates for the direct and FH estimators using boxplots and ordered scatter plots (by setting the input arguments `MSE` and `CV` to `TRUE`).

Additionally, we compute a correlation coefficient of the direct estimates and the estimates of the regression-synthetic part of the FH model [@Chandra2015] and a goodness of fit diagnostic [@Brown2001].

```{r compare, message = FALSE, warning = FALSE}
compare_plot(fh_model, MSE = TRUE, CV = TRUE)
compare(fh_model)

```

The direct estimates are tracked by most of the FH estimates within the line plot. The precision of the direct estimates could be improved by the usage of the FH model in terms of MSEs and CVs. The null hypothesis of the Brown test is not rejected and the correlation coefficient indicates a positive correlation (0.66) between the direct and FH estimates.

If the result of the model assessment is not satisfactory, the following should be checked again: Can the direct estimation including variance estimation be improved? Are there further auxiliary variables and/or must possible interaction effects be taken into account? Does a (different) transformation need to be used?

## Benchmark the FH point estimates for consistency with higher results.

Benchmarking is based on the principle that aggregated FH estimates should sum up to the estimates at a higher regional level. For the benchmark function, a benchmark value and a vector containing the shares of the population size per area ($N_d/N$) is required. Please note, that only the FH estimates are benchmarked and not their MSE estimates. As benchmark types "raking", "ratio" and "MSE_adj" can be chosen. For further details about using the function, please refer to the `emdi` vignette and for general information about the benchmarking options to @Datta2011.

```{r benchmarking, message = FALSE, warning = FALSE}
## compute the benchmark value (mean of poverty indicator for the whole country)
benchmark_value <- weighted.mean(survey_dt$pov_indicator, survey_dt[[weight_var]])

## compute the share of population size in the total population size (N_d/N) per area
data("sizeprov")
fh_dt <- fh_dt |>
  left_join(sizeprov |>
  mutate(ratio_n = Nd/sum(Nd)), by = c("Domain" = area_vars[1]))

fh_bench <- benchmark(fh_model,
                      benchmark = benchmark_value,
                      share = fh_dt$ratio_n, 
                      type = "ratio",
                      overwrite = TRUE)
head(fh_bench$ind)
```

## Preparation of the results.

Create one dataframe that contains the direct and FH estimation results including MSE and CV results.

```{r res_prep, message = FALSE, warning = FALSE}
pov_fh <- as.data.frame(estimators(fh_model, MSE = TRUE, CV = TRUE))
head(pov_fh)

pov_fh <- pov_fh |>
  rename(!!area_vars[1] := "Domain") |>
  mutate(year = singleyear)

bd_out |>
  pin_write(x = pov_fh,
            name = "pov_fh",
            type = "rds")

write.csv(pov_fh, "data/clean-example/pov_fh.csv")
```

### Poverty map

With the help of geographical maps, the results can be presented in a user-friendly way and differences among the areas can be detected more easily. For the map, a shape file is reqired. The domain identifiers in the results object (`fh_model`) need to match to the respective identifiers of the shape file. Therefore, we create a mapping table first and then produce the map by `emdi::map_plot`.

```{r fig-povmap}
## Create a suitable mapping table
## Find the right order
domain_ord <- match(shp_dt[[area_vars[1]]], fh_model$ind$Domain)

## Create the mapping table based on the order obtained above
map_tab <- data.frame(pop_data_id = fh_model$ind$Domain[domain_ord],
                      shape_id = shp_dt[[area_vars[1]]])

## Create map
map_plot(object = fh_model, MSE = TRUE, map_obj = shp_dt,
 map_dom_id = area_vars[1], map_tab = map_tab)

```

## Saving the results.

### Save workspace.

```{r save, message = FALSE, warning = FALSE, eval = FALSE}
save.image("fh_estimation.RData")
### save the data to pin board

```

### Export the model output and estimation results.

```{r saveexcel, message = FALSE, warning = FALSE, eval = FALSE}
write.excel(fh_model,
  file = "fh_model_output.xlsx",
  MSE = TRUE, CV = TRUE
)
```